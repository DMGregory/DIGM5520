<html>
  <head>
    <meta charset="UTF-8" />
    <style>
      * {
        margin: 0;
      }
    </style>
    <!-- <link rel="stylesheet" type="text/css" href="styles.css"> -->
  </head>
  <body>
    <script type="module">
      'use strict';

      import * as THREE from 'https://unpkg.com/three@0.126.0/build/three.module.js';
      import { VRButton } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/webxr/VRButton.js';
      import { OrbitControls } from 'https://unpkg.com/three@0.126.0/examples/jsm/controls/OrbitControls.js';

      const clock = new THREE.Clock();
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;

      document.body.appendChild(renderer.domElement);
      document.body.appendChild(VRButton.createButton(renderer));

      function vectorToString(v) {
        return `(${v.x}, ${v.y}, ${v.z})`;
      }

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.05,
        100
      );
      camera.position.y = 1.5;
      camera.position.z = 1.5;

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 0.75, 0);
      controls.domElement.onpointerenter = function () {
        controls.enabled = true;
      };

      controls.domElement.onpointerout = function () {
        controls.enabled = false;
      };

      function resize() {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      }
      resize();
      window.addEventListener('resize', resize, false);

      // create the root of a scene graph
      const scene = new THREE.Scene();

      const fadeColor = 0x3030c5;
      scene.background = new THREE.Color(fadeColor);
      scene.fog = new THREE.FogExp2(fadeColor, 0.3);

      const geometry = new THREE.BoxGeometry();
      const material = new THREE.MeshLambertMaterial();
      const cube = new THREE.Mesh(geometry, material);

      // position the cube, and add it to the scene:
      cube.position.y = 1.5;
      cube.position.z = -2.0;
      cube.castShadow = true;
      scene.add(cube);

      const secondCube = new THREE.Mesh(geometry, material);
      secondCube.position.y = 1.5;
      secondCube.position.z = -2.0;
      secondCube.position.x = 1.5;
      secondCube.castShadow = true;
      scene.add(secondCube);

      const floor = new THREE.Mesh(new THREE.PlaneGeometry(40, 40), material);
      floor.receiveShadow = true;
      floor.rotation.x = -Math.PI / 2;
      scene.add(floor);

      const grid = new THREE.GridHelper(35, 35, 0x333366, 0x666666);
      scene.add(grid);

      const light = new THREE.HemisphereLight(0xfffcee, 0x202555);
      scene.add(light);

      //const directional = new THREE.DirectionalLight(0xfff2dd, 1.0);
      //directional.position.set(-1, 7, 0.5);
      //renderer.shadowMap.enabled = true;
      //renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      //directional.castShadow = true;
      //scene.add(directional);

      const ico = new THREE.Mesh(
        new THREE.IcosahedronGeometry(0.1),
        new THREE.MeshLambertMaterial({ color: 0xff0000 })
      );
      ico.position.z = -1;
      scene.add(ico);

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }
      renderer.domElement.onmousemove = onMouseMove;

      let gazeObject = null;

      const particleCount = 100;
      const particleSize = 0.3;
      const particleColor = 0x22ff33;
      const particleGeo = new THREE.PlaneGeometry(particleSize, particleSize);

      const rootTex = new THREE.TextureLoader().load(
        'https://cdn.jsdelivr.net/gh/DMGregory/DIGM5520@master/Week1/RootParticleCutout.jpg'
      );
      const particleFeet = new THREE.InstancedMesh(
        particleGeo,
        new THREE.MeshBasicMaterial({
          color: particleColor,
          alphaMap: rootTex,
          alphaTest: 0.5,
        }),
        particleCount
      );
      particleFeet.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      scene.add(particleFeet);

      const grassTex = new THREE.TextureLoader().load(
        'https://cdn.jsdelivr.net/gh/DMGregory/DIGM5520@master/Week1/GrassParticleCutout.jpg'
      );

      const particles = new THREE.InstancedMesh(
        particleGeo,
        new THREE.MeshBasicMaterial({
          color: particleColor,
          alphaMap: grassTex,
          alphaTest: 0.5,
          side: THREE.DoubleSide,
        }),
        particleCount
      );
      particles.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      scene.add(particles);

      let particleInfo = [];
      for (let i = 0; i < particleCount; i++) {
        particleInfo.push({
          position: new THREE.Vector3(0, -1, 0),
          intensity: 0,
        });
      }

      const dummy = new THREE.Object3D();
      const dummy2 = new THREE.Object3D();

      const readout = document.createElement('div');
      readout.style.position = 'absolute';
      readout.style.top = '0px';
      document.body.appendChild(readout);

      function animate() {
        const dt = clock.getDelta();
        controls.update(dt);

        if (renderer.xr && renderer.xr.isPresenting) {
          mouse.set(0, 0);
        }

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects([
          cube,
          secondCube,
          floor,
        ]);

        let newGaze = null;
        if (intersects.length > 0) {
          ico.position.copy(intersects[0].point);
          newGaze = intersects[0].object;
        }

        let faintest = 0;
        let near = 0;
        for (let i = 0; i < particleCount; i++) {
          let p = particleInfo[i];
          let d = ico.position.distanceToSquared(p.position) * 2;

          let h = Math.max(1.0 - d, 0);

          if (h > 0) {
            near++;
            p.intensity = Math.min(
              1,
              Math.max(0, p.intensity + 0.01 * (h - p.intensity))
            );
          } else {
            p.intensity = Math.max(0, p.intensity - (1 - p.intensity) * 0.01);
          }

          if (p.intensity < particleInfo[faintest].intensity) faintest = i;

          dummy.position.copy(p.position);

          dummy.position.y += 0.01;
          dummy.rotation.set(-Math.PI / 2, 0, i);
          const s = Math.max(Math.sqrt(p.intensity) - 0.2, 0)*2;
          dummy.scale.set(s, s, s);
          dummy.updateMatrix();
          particleFeet.setMatrixAt(i, dummy.matrix);

          dummy2.position.copy(p.position);
          dummy2.position.y += (p.intensity - 0.5) * particleSize * 1.2;
          dummy2.rotation.set(0, i, -Math.PI/4);
          dummy2.scale.set(1, 1, 1);
          dummy2.updateMatrix();
          particles.setMatrixAt(i, dummy2.matrix);
        }
        particles.instanceMatrix.needsUpdate = true;
        particleFeet.instanceMatrix.needsUpdate = true;

        if (near < particleCount/2 && particleInfo[faintest].intensity < 0.01) {
          if (newGaze == floor) {
            particleInfo[faintest].position.random();
            particleInfo[faintest].position.multiplyScalar(0.5);
            particleInfo[faintest].position.y = 0;
            particleInfo[faintest].position.add(ico.position);
            particleInfo[faintest].intensity = 0.1;
          }
        } else {
          particleInfo[faintest].intensity *= 0.5;
        }

        // update the scene:
        cube.rotation.x += 0.01;
        cube.rotation.y += 0.01;

        // draw the scene:
        renderer.render(scene, camera);
      }
      // start!
      renderer.setAnimationLoop(animate);
    </script>
  </body>
</html>
