<!--
  Douglas Gregory - 219033117

  This was my first WebXR scne produced in week 1,
  to get some practice working with THREE.js and VR in the browser.

  It demonstrates some basics:
  - Setting up an animated THREE.js scene with a button to enter VR
  - Tracking an "attention point" in the scene using a raycast, from either
    a browser user's mouse cursor, or the direction of a VR user's gaze.
  - Spawning and animating a particle system with InstancedMesh

  I wanted an interaction that would happen automatically when a user visited the scene,
  so they wouldn't need to know some "trick" to activate it, and wouldn't require a
  specialized input peripheral like an Oculus Touch controller (for now).

  I also wanted it to convey a sense of the wonder of inhabiting a responsive virtual
  space that can react to you in ways ordinary spaces don't. So I styled my particle
  system as a patch of waving grass that would grow from the ground wherever you pointed
  or looked, vibrant green against the plain greyish starting scene.

  This works by spawning all the grass planes invisibly under the floor plane, and lifting/scaling
  them to give the appearance of growth. A slight sinusoidal rotation is added to mimic wind.

  I use an array of position vectors and intensity values for each particle. Particles near the gaze
  grow in intensity (up to 1), and particles farther away reduce in intensity (toward zero).
  I use these positions and intensity values to update the grass particle positions, higher
  intensity = bigger/more fully risen above the floor, while low intensity shrinks down.

  Each frame I grab a particle with low enough intensity to be invisible (if there are any)
  and teleport it to a random position near the gaze point, to build up the density there. 

  The grass consists of two quad parts: the upright blades that rise out of the ground,
  and an outward "splat" that sits against the ground plane and scales up as the grass grows,
  helping to mask the sharp line where the upright quads intersect the floor.
  I draw one of each part at each position in my array, driving the position/scale of both
  using the same intensity value.
-->


<html>
  <head>
    <meta charset="UTF-8" />
    <style>
      * {
        margin: 0;
      }
    </style>
    <!-- <link rel="stylesheet" type="text/css" href="styles.css"> -->
  </head>
  <body>
    <script type="module">
      'use strict';

      // Import the modules we're using.
      import * as THREE from 'https://unpkg.com/three@0.126.0/build/three.module.js';
      import { VRButton } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/webxr/VRButton.js';
      import { OrbitControls } from 'https://unpkg.com/three@0.126.0/examples/jsm/controls/OrbitControls.js';

      // THREE.js setup boilerplate. Set up our clock, renderer, canvas, VR button.
      const clock = new THREE.Clock();
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;

      document.body.appendChild(renderer.domElement);
      document.body.appendChild(VRButton.createButton(renderer));

      // Set up the camera far enough back to look at the spinning cube we made in class.
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.05,
        100
      );
      camera.position.y = 1.5;
      camera.position.z = 1.5;

      // Size the canvas to the current screen, and keep it up to date 
      // if the window changes size.
      function resize() {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      }
      resize();
      window.addEventListener('resize', resize, false);

      // Set up controls for orbiting around the scene with click
      // and drag in the browser.
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 0.75, 0);

      // create the root of a scene graph
      const scene = new THREE.Scene();

      // Create a plain grey material we can use for some simple scenery.
      const material = new THREE.MeshLambertMaterial();


      // Add some fog matched to our background colour to hide
      // where the world ends, and give it some atmospheric perspective.
      
      // I found this trick from https://threejs.org/examples/#webgl_loader_fbx
      // along with the floor and grid that come next, but I made my 
      // background blue to look a bit more inviting and sky-like, and 
      // to work with the bluish shadows I painted into my grass textures.
      const fadeColor = 0x5099c5;
      scene.background = new THREE.Color(fadeColor);
      scene.fog = new THREE.FogExp2(fadeColor, 0.1);

      const floor = new THREE.Mesh(new THREE.PlaneGeometry(40, 40), material);
      floor.receiveShadow = true;
      floor.rotation.x = -Math.PI / 2;
      scene.add(floor);

      const grid = new THREE.GridHelper(35, 35, 0x333366, 0x666666);
      scene.add(grid);

      const geometry = new THREE.BoxGeometry();
      
      const cube = new THREE.Mesh(geometry, material);

      // position the cube, and add it to the scene:
      cube.position.y = 1.5;
      cube.position.z = -2.0;
      cube.castShadow = true;
      scene.add(cube);

      const secondCube = new THREE.Mesh(geometry, material);
      secondCube.position.y = 1.5;
      secondCube.position.z = -2.0;
      secondCube.position.x = 1.5;
      secondCube.castShadow = true;
      scene.add(secondCube);



      const light = new THREE.HemisphereLight(0xfffcee, 0x202555);
      scene.add(light);

      /* I experimented with adding shadows, but they don't look so good
      with the cartoon-style grass I made, so I turned them off again. 

      const directional = new THREE.DirectionalLight(0xfff2dd, 1.0);
      directional.position.set(-1, 7, 0.5);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      directional.castShadow = true;
      scene.add(directional);
      */

      const ico = new THREE.Mesh(
        new THREE.IcosahedronGeometry(0.1),
        new THREE.MeshLambertMaterial({ color: 0xff0000 })
      );
      ico.position.z = -1;
      scene.add(ico);

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }
      renderer.domElement.onmousemove = onMouseMove;

      let gazeObject = null;

      const particleCount = 200;
      const particleSize = 0.3;
      const particleColor = 0x22ff33;
      const particleGeo = new THREE.PlaneGeometry(particleSize, particleSize);

      const rootTex = new THREE.TextureLoader().load(
        'https://cdn.jsdelivr.net/gh/DMGregory/DIGM5520@master/Week1/RootParticleCutout.jpg'
      );
      const particleFeet = new THREE.InstancedMesh(
        particleGeo,
        new THREE.MeshBasicMaterial({
          color: 0x11e533,
          alphaMap: rootTex,
          alphaTest: 0.5,
        }),
        particleCount
      );
      particleFeet.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      scene.add(particleFeet);

      const grassTex = new THREE.TextureLoader().load(
        'https://cdn.jsdelivr.net/gh/DMGregory/DIGM5520@master/Week1/GrassParticleCutout.jpg'
      );

      const grassGrad = new THREE.TextureLoader().load(
        'https://cdn.jsdelivr.net/gh/DMGregory/DIGM5520@master/Week1/WhiteBlueGradientSwatch.jpg'
      );

      const particles = new THREE.InstancedMesh(
        particleGeo,
        new THREE.MeshBasicMaterial({
          color: particleColor,
          map: grassGrad,
          alphaMap: grassTex,
          alphaTest: 0.5,
          side: THREE.DoubleSide,
        }),
        particleCount
      );
      particles.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      scene.add(particles);

      let particleInfo = [];
      for (let i = 0; i < particleCount; i++) {
        particleInfo.push({
          position: new THREE.Vector3(0, -1, 0),
          intensity: 0,
        });
      }

      const dummy = new THREE.Object3D();
      const dummy2 = new THREE.Object3D();

      const readout = document.createElement('div');
      readout.style.position = 'absolute';
      readout.style.top = '0px';
      document.body.appendChild(readout);





      function animate() {
        const dt = clock.getDelta();
        const t = clock.getElapsedTime();

        controls.update(dt);

        if (renderer.xr && renderer.xr.isPresenting) {
          mouse.set(0, 0);
        }

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects([
          cube,
          secondCube,
          floor,
        ]);

        let newGaze = null;
        if (intersects.length > 0) {
          ico.position.copy(intersects[0].point);
          newGaze = intersects[0].object;
        }

        let faintest = 0;
        let near = 0;
        for (let i = 0; i < particleCount; i++) {
          let p = particleInfo[i];
          let d = ico.position.distanceToSquared(p.position) * 2;

          let h = Math.max(1.0 - d, 0);
          
          if (h > 0) {            
            p.intensity = Math.min(
              1,
              Math.max(0, p.intensity + 0.01 * (h - p.intensity))
            );
            if (h > 0.7) near++;
          } else {
            p.intensity = Math.max(0, p.intensity - (1 - p.intensity) * 0.01);
          }

          if (p.intensity < particleInfo[faintest].intensity) faintest = i;

          dummy.position.copy(p.position);

          dummy.position.y += 0.01;
          dummy.rotation.set(-Math.PI / 2, 0, i);
          const s = Math.max(p.intensity - 0.2, 0)*2;
          dummy.scale.set(s, s, s);
          dummy.updateMatrix();
          particleFeet.setMatrixAt(i, dummy.matrix);

          dummy2.position.copy(p.position);
          dummy2.position.y += (p.intensity - 0.5) * particleSize * 1.2;
          dummy2.rotation.set(0, i, -Math.PI/4 + Math.sin(3 * t + i)*0.1);
          dummy2.scale.set(1, 1, 1);
          dummy2.updateMatrix();
          particles.setMatrixAt(i, dummy2.matrix);
        }
        particles.instanceMatrix.needsUpdate = true;
        particleFeet.instanceMatrix.needsUpdate = true;

        if (near < particleCount * 0.5 && particleInfo[faintest].intensity < 0.01) {
          if (newGaze == floor) {
            particleInfo[faintest].position.random();
            particleInfo[faintest].position.multiplyScalar(0.5);
            particleInfo[faintest].position.y = 0;
            particleInfo[faintest].position.add(ico.position);
            particleInfo[faintest].intensity = 0.1;
          }
        } else {
          particleInfo[faintest].intensity *= 0.5;
        }

        // update the scene:
        cube.rotation.x += 0.01;
        cube.rotation.y += 0.01;

        ico.rotation.x -= 0.01;
        ico.rotation.y -= 0.01;

        // draw the scene:
        renderer.render(scene, camera);
      }
      // start!
      renderer.setAnimationLoop(animate);
    </script>
  </body>
</html>
